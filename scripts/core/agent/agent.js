define([
    'lodash',
    '../../util/agent-goals.js',
    '../random.js',
    '../localization/location.js',
    '../../util/world-parameters.js',
    './dna-random-gene.js',
], function (_, AgentGoals, Generator, Location, WorldParameters, ObjectDNA) {
    var Agent = function(objectDNA, location) {
        var myself = this;
        var generator = new Generator(objectDNA.getDNA());
        var previousLocations = [];
        var currentLocation = location;

        var id = null;

        var agentData = {
            alive: true,
            age: 0,
        };

        var currentGoal = null;
        var currentTarget = null;

        var containerWorld = null;

        this.weight = 0;
        this.threat = 0;

        var die = function() {
            agentData.alive = false;

            if(!_.isNil(myself.getWorld())) {
                myself.getWorld().removeAgent(myself, currentLocation);
            }
        };

        // SPEEDS
        agentData.speed = {};
        agentData.speed.mainSpeed = null;
        agentData.speed.speeds = null; // array of speed for every terrains.
        agentData.speed.canMove = true;
        var initializeSpeeds = function() {
            agentData.speed.speeds = {};

            var plantChance = generator.getInt(2, 5);
            var plantRoll = generator.getInt(0, plantChance);
            var speedCoefficient = 1 + generator.getFloat();

            if (plantRoll === 1) {
                // is a plant
                agentData.speed.mainSpeed = 0;
                agentData.speed.canMove = false;
            } else {
                // is a moving creature
                // Speed boundaries
                var maxMaxSpeed = generator.getInt(2, 5) * speedCoefficient;
                var minSpeed = generator.getFloatInRange(0, 0.9) * speedCoefficient;
                var maxSpeed = generator.getFloatInRange(
                    minSpeed,
                    maxMaxSpeed
                );
                agentData.speed.mainSpeed = generator.getFloatInRange(
                    minSpeed,
                    maxSpeed
                );
            }
            var seed = objectDNA.getSpeedSeed();

            // Second generator so if we decide to add new terrains,
            // the rest of the number generated by the main generator won't change.
            var speedGenerator = new Generator(seed);

            _.forEach(WorldParameters, function(terrainParamters, terrainParameterName) {
                agentData.speed.speeds[terrainParameterName] = {};
                _.forEach(terrainParamters, function(option) {
                    agentData.speed.speeds[terrainParameterName][option] =
                        speedGenerator.getFloatInRange(0, speedCoefficient);
                });
            });
        };

        this.isPlant = function() {
            return !agentData.speed.canMove;
        };

        /**
        * get the speed of the agent for the given WorldStatus
        */
        this.getSpeed = function(worldStatus) {
            var speed = agentData.speed.mainSpeed;
            _.forEach(worldStatus.getParameters(), function(option ,terrainParamter) {
                speed = speed * agentData.speed.speeds[terrainParamter][option];
            });
            return speed;
        };
        ///////////////

        // FOOD PART
        agentData.food = {};
        agentData.food.hungry = null; // current hunger status.
        agentData.food.deathByHunger = null; // if hunger is above this, agent die.
        agentData.food.hungerRate = null; // hunger spend every cycle.
        agentData.food.hungerMove = null; // hunger spend every 1 unit of movement done.
        var initializeHunger = function() {
            var hungerMaxOriginal = generator.getInt(0, 30);
            agentData.food.hungry = generator.getInt(0, hungerMaxOriginal);
            var bonusHungerSurvival = generator.getFloatInRange(0.6, 5);
            agentData.food.deathByHunger = generator.getInt(
                hungerMaxOriginal,
                100 * bonusHungerSurvival
            );

            agentData.food.hungerRate = generator.getFloatInRange(0.1, hungerMaxOriginal / 3.0);
            agentData.food.hungerMove = generator.getFloatInRange(0, 1);
        };

        var spendHunger = function(hungerSpent) {
            agentData.food.hungry = agentData.food.hungry + hungerSpent;

            if (agentData.food.hungry >= agentData.food.deathByHunger) {
                die();
            }
        };

        this.canEat = function(agent) {
            // TODO
            return true;
        };
        ///////////////

        // Reproduction
        agentData.reproduction = {};
        agentData.reproduction.kidQuantity = {
            min: null,
            max: null,
        };
        agentData.reproduction.mutationRate = null;
        agentData.reproduction.failingBirthRate = null;
        agentData.reproduction.waitingPeriod = null;
        agentData.reproduction.timeToNextKid = 0;
        var initializeReproductiveFunction = function() {
            var maxPossibleKid = generator.getInt(1, 100) * generator.getFloatInRange(0.1, 0.6);
            agentData.reproduction.kidQuantity.max = generator.getInt(1, maxPossibleKid);
            agentData.reproduction.kidQuantity.min =
                generator.getInt(1, agentData.reproduction.kidQuantity.max);

            var maxMutationRate = generator.getFloatInRange(0, 0.9);
            agentData.reproduction.mutationRate = generator.getFloatInRange(0, maxMutationRate);

            var maxFailingBirthRate = generator.getFloatInRange(0, 0.9);
            agentData.reproduction.failingBirthRate =
                generator.getFloatInRange(0, maxFailingBirthRate);

            // TODO: When we run a few agent, we need to see how many cycle they live
            // in average. We want them to be able to reproduce at least once.
            // the max of this number should be 1.5 times their life expectancy.
            var maxWaitingTime = generator.getInt(2, 50);
            agentData.reproduction.waitingPeriod = generator.getInt(1, maxWaitingTime);
        };

        this.canReproduceWith = function(agent) {
            if (agentData.reproduction.timeToNextKid > 0) {
                return false;
            }
            // TODO
            return true;
        };

        var createChildWith = function(agent) {
            if (!myself.canReproduceWith(agent) || !agent.canReproduceWith(myself)) {
                return null;
            }
            var myDNA = myself.getDNA();
            var myDNALength = myDNA.length;
            var otherDNA = agent.getDNA();
            var otherDNALength = otherDNA.length;

            var newLocation = myself.getLocation();

            var newDNA = '';

            for (var i = 0; i < Math.max(myDNALength, otherDNALength); i++) {
                var gene = '';
                var myDNAAvailable = i < myDNALength;
                var otherDNAAvailable = i < otherDNALength;
                var willMutate = generator.getFloat() < agentData.reproduction.mutationRate;
                var WillStop = i > (myDNALength + otherDNALength) / 2.0 * (0.5 + generator.getFloat());

                if (WillStop) {
                    break;
                }

                if (willMutate) {
                    newDNA += generator.getChar();
                } else {
                    if (myDNAAvailable && otherDNAAvailable) {
                        newDNA += generator.getFloat() <= 0.5
                            ? myDNA[i]
                            : otherDNA[i];
                    }

                    if (!myDNAAvailable && !otherDNAAvailable) {
                        newDNA += generator.getChar();
                    }

                    if (!myDNAAvailable && otherDNAAvailable) {
                        newDNA += otherDNA[i];
                    }

                    if (myDNAAvailable && !otherDNAAvailable) {
                        newDNA += myDNA[i];
                    }
                }
            }

            var newObjectDNA = new ObjectDNA(newDNA);
            var child = new Agent(newObjectDNA, newLocation);

            if (generator.getFloat() < agentData.reproduction.failingBirthRate) {
                child.kill();
            }

            return child;
        };

        this.reproduceWith = function(agent) {
            if (!myself.canReproduceWith(agent) || !agent.canReproduceWith(myself)) {
                return [];
            }

            var kidQuantity = generator.getInt(
                agentData.reproduction.kidQuantity.min,
                agentData.reproduction.kidQuantity.max
            );
            var kids = [];

            _.times(kidQuantity, function() {
                kids.push(createChildWith(agent));
            });

            agentData.reproduction.timeToNextKid = agentData.reproduction.waitingPeriod;
            agent.getData().reproduction.timeToNextKid = agent.getData().reproduction.waitingPeriod;

            return kids;
        };
        ///////////////


        // Sleep
        agentData.energy = {};
        agentData.energy.tired = null;
        agentData.energy.deathByExhaustion = null;
        agentData.energy.exhaustionRate = null;
        agentData.energy.exhaustionMove = null;
        var initializeSleep = function() {
            var sleepMaxOriginal = generator.getInt(0, 30);
            agentData.energy.tired = generator.getInt(0, sleepMaxOriginal);
            var bonusSleepSurvival = generator.getFloatInRange(0.6, 5);
            agentData.energy.deathByExhaustion = generator.getInt(
                sleepMaxOriginal,
                100 * bonusSleepSurvival
            );

            agentData.energy.exhaustionRate = generator.getFloatInRange(0.1, sleepMaxOriginal / 3.0);
            agentData.energy.exhaustionMove = generator.getFloatInRange(0, 1);
        };

        var spendEnergy = function(energySpent) {
            agentData.energy.tired = agentData.energy.tired + energySpent;

            if (agentData.energy.tired >= agentData.energy.deathByExhaustion) {
                die();
            }
        };
        /////////////

        // Extra Traits
        agentData.playful = {};
        agentData.playful.curiosity = null;
        agentData.playful.playful = null;
        agentData.playful.looseCuriosityWithAgeCoef = null;
        agentData.playful.loosePlayfulWithAgeCoef = null;
        var initializeExtraTraits = function() {
            // curiosity
            agentData.playful.curiosity = generator.getInt(10, 90);
            agentData.playful.looseCuriosityWithAgeCoef = generator.getFloatInRange(0.01, 0.99);

            // playful
            agentData.playful.playful = generator.getInt(10, 90);
            agentData.playful.loosePlayfulWithAgeCoef = generator.getFloatInRange(0.01, 0.99);
        };

        var loseFun = function() {
            agentData.playful.curiosity =
                agentData.playful.curiosity * agentData.playful.looseCuriosityWithAgeCoef;
            agentData.playful.playful =
                agentData.playful.playful * agentData.playful.loosePlayfulWithAgeCoef;
        };
        /////////////

        // Brain
        var decideGoal = function() {
            // TODO: Should build a system which for each "Goal" has 4 steps
            // intent / search / move / action
            var allGoals = _.cloneDeep(AgentGoals);

            if (!agentData.alive) {
                currentGoal = allGoals.dead;
                return currentGoal;
            } else {
                allGoals.dead.score = 0;
            }

            // Fun
            allGoals.exploring.score = agentData.playful.curiosity;
            allGoals.play.score = agentData.playful.playful;
            ////

            // going to get food
            var closeToDieFromHunger = agentData.food.deathByHunger - agentData.food.hungry;
            allGoals.lookingForFood.score = 100.0 / closeToDieFromHunger;
            if (currentTarget && myself.canEat(currentTarget)) {
                allGoals.goingToTarget.score = allGoals.lookingForFood.score;
                allGoals.lookingForFood.score = 0;
            }
            /////

            // going to sleep
            var closeToDieFromExhaustion =
                agentData.energy.deathByExhaustion - agentData.energy.tired;
            allGoals.sleeping.score = 100.0 / closeToDieFromExhaustion;
            //////

            // reproduce
            if (allGoals.goingToTarget.score < 70
                && allGoals.lookingForFood.score < 70
                && allGoals.sleeping.score < 70 ) {

                var closeToAbleToReproduce =
                    agentData.reproduction.timeToNextKid / agentData.reproduction.waitingPeriod;
                if (currentTarget
                    && myself.canReproduceWith(currentTarget)
                    && currentTarget.canReproduceWith(myself)) {

                    allGoals.reproduction.score = 100 - (closeToDieFromHunger * 100.0);
                    allGoals.lookingForMate.score = 0;
                } else {
                    allGoals.lookingForMate.score = 100 - (closeToDieFromHunger * 100.0);
                    allGoals.reproduction.score = allGoals.lookingForMate.score - 1;
                }
            }
            /////

            currentGoal = _.head(_.sortBy(allGoals, function(g) {
                return g.score;
            }));
            return currentGoal;
        };

        this.getCurrentGoal = function() {
            return currentGoal;
        };
        /////////////

        var moveTo = function(location) {
            if(!_.isNil(myself.getWorld())) {
                if (location && !location.equals(currentLocation)) {
                    myself.getWorld().updateAgentPerLocation(
                        myself,
                        location,
                        currentLocation);
                }
            }

            if (!location) {
                previousLocations.push(currentLocation);
                return;
            }

            var distance = location.distance(currentLocation);

            spendHunger(agentData.food.hungerMove * distance);
            spendEnergy(agentData.energy.exhaustionMove * distance);

            previousLocations.push(currentLocation);
            currentLocation = location;
        };

        this.cycle = function(newLocation = null, autonomous = false) {
            decideGoal();
            moveTo(newLocation);
            spendHunger(agentData.food.hungerRate);
            spendEnergy(agentData.energy.exhaustionRate);

            agentData.age += 0.1;
            if (agentData.reproduction.timeToNextKid > 0) {
                agentData.reproduction.timeToNextKid -= 1;
            }
            loseFun();
        };

        this.kill = function() {
            die();
        };

        this.isAlive = function() {
            return agentData.alive;
        };

        // GET METHODS
        this.getLocation = function() {
            return currentLocation;
        };

        this.getAge = function() {
            return agentData.age;
        };

        this.getData = function() {
            return agentData;
        };

        this.getDNA = function() {
            return objectDNA.getDNA();
        };

        this.setID = function(newID) {
            if (!_.isNil(id)) {
                throw new `ID is already set. ID: ${id}`;
            }

            id = newID;
        };

        this.getID = function() {
            if (_.isNil(id)) {
                throw 'ID needs to be set for this agent.';
            }
            return id;
        };

        this.setWorld = function(world) {
            containerWorld = world;
        };

        this.getWorld = function() {
            return containerWorld;
        };
        /////////////

        this.serialize = function() {
            return JSON.stringify(agentData);
        };

        var initAll = function() {
            initializeSpeeds();
            initializeHunger();
            initializeSleep();
            initializeExtraTraits();
            initializeReproductiveFunction();
        };

        initAll();
    };

    Agent.createNewAgent = function(generator, location) {
        var dna = ObjectDNA.createNewDNA(generator);
        return new Agent(dna, location);
    }

    return Agent;
});
